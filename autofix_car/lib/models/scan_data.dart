// lib/models/scan_data.dart
import 'package:flutter/material.dart'; // For IconData, Color

enum ScanStatus {
  faultsDetected,
  needsAttention,
  noFaults,
  pending, // For ongoing scans, or if results are still being processed
  unknown,
}

class ScanData {
  final String? id; // Nullable for new scans before backend assigns ID
  final String? imagePath; // URL or path to the captured image (can be null)
  final String title; // Main summary of the scan
  final String description; // Detailed description of the scan result
  final ScanStatus status; // The outcome of the scan
  final DateTime scanDateTime; // When the scan was performed
  final Map<String, dynamic>?
  metadata; // Optional additional data (e.g., error codes, more details)

  ScanData({
    this.id,
    this.imagePath,
    required this.title,
    required this.description,
    required this.status,
    DateTime? scanDateTime, // Made optional with default
    this.metadata,
  }) : scanDateTime =
           scanDateTime ??
           DateTime.now(); // Default to current time if not provided

  factory ScanData.fromJson(Map<String, dynamic> json) {
    // Handle various timestamp formats from backend
    DateTime parsedTimestamp;
    if (json['scan_date_time'] is String) {
      parsedTimestamp = DateTime.parse(json['scan_date_time'] as String);
    } else if (json['scan_date_time'] is int) {
      parsedTimestamp = DateTime.fromMillisecondsSinceEpoch(
        json['scan_date_time'] as int,
      );
    } else {
      parsedTimestamp = DateTime.now(); // Fallback
    }

    return ScanData(
      id: json['id'] as String?,
      imagePath: json['image_path'] as String?,
      title: json['title'] as String,
      description: json['description'] as String,
      status: ScanStatus.values.firstWhere(
        (e) => e.toString().split('.').last == json['status'],
        orElse: () =>
            ScanStatus.unknown, // Default if status string doesn't match enum
      ),
      scanDateTime: parsedTimestamp,
      metadata: json['metadata'] as Map<String, dynamic>?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      // 'id': id, // ID usually generated by backend
      'image_path': imagePath,
      'title': title,
      'description': description,
      'status': status.toString().split('.').last, // Convert enum to string
      'scan_date_time': scanDateTime
          .toIso8601String(), // Send as ISO 8601 string
      'metadata': metadata,
    };
  }

  ScanData copyWith({
    String? id,
    String? imagePath,
    String? title,
    String? description,
    ScanStatus? status,
    DateTime? scanDateTime,
    Map<String, dynamic>? metadata,
  }) {
    return ScanData(
      id: id ?? this.id,
      imagePath: imagePath ?? this.imagePath,
      title: title ?? this.title,
      description: description ?? this.description,
      status: status ?? this.status,
      scanDateTime: scanDateTime ?? this.scanDateTime,
      metadata: metadata ?? this.metadata,
    );
  }

  // Helper methods for UI based on status
  Color get statusColor {
    switch (status) {
      case ScanStatus.faultsDetected:
        return Colors.redAccent;
      case ScanStatus.needsAttention:
        return Colors.orangeAccent;
      case ScanStatus.noFaults:
        return Colors.green;
      case ScanStatus.pending:
        return Colors.blueAccent;
      case ScanStatus.unknown:
        return Colors.grey;
    }
  }

  IconData get statusIcon {
    switch (status) {
      case ScanStatus.faultsDetected:
        return Icons.error_outline;
      case ScanStatus.needsAttention:
        return Icons.warning_amber_rounded;
      case ScanStatus.noFaults:
        return Icons.check_circle_outline;
      case ScanStatus.pending:
        return Icons.hourglass_empty;
      case ScanStatus.unknown:
        return Icons.help_outline;
    }
  }
}
